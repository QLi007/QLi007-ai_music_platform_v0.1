# AI音乐平台 V0.5 - 区块链激励版本

## 1. 系统概述

V0.5版本在V0.4基础上添加了区块链激励系统,实现创作者通证激励和NFT音乐资产功能。

### 1.1 系统架构
```yaml
架构图:
                    ┌→ [用户认证服务8081]
                    ├→ [音乐生成服务8080]
  [前端Next.js] → [API网关] → [社交功能服务8082]
                    ├→ [推荐系统服务8083]
                    └→ [区块链服务8084]
                           ↓
              [PostgreSQL & Redis & Blockchain]
```

### 1.2 核心功能
```yaml
继承V0.4功能:
  - AI音乐生成API调用
  - 用户认证授权
  - 社交互动功能
  - 智能推荐系统
  
新增功能:
  - 创作者通证发行
  - NFT音乐铸造
  - 通证交易市场
  - 版税分成系统
  - 创作者激励机制
```

## 2. 技术栈

### 2.1 后端技术
```yaml
框架与库:
  - Spring Boot 3.2
  - Spring Security
  - Spring Data JPA
  - Spring Web
  - Spring Actuator
  - Web3j (以太坊交互)
  - IPFS (去中心化存储)
  - Lombok
  - MapStruct
  - OpenAPI (Swagger)

区块链:
  - Ethereum/Polygon
  - Solidity (智能合约)
  - Hardhat (开发框架)
  - OpenZeppelin (合约库)

数据库与缓存:
  - PostgreSQL 14
  - Redis (缓存)
  - IPFS (音乐文件)
  - Flyway (数据库迁移)

构建工具:
  - Maven
  - Docker
  - Docker Compose

测试:
  - JUnit 5
  - Testcontainers
  - REST Assured
  - Hardhat Test
```

### 2.2 前端技术
```yaml
框架与库:
  - Next.js 14
  - React 18
  - TypeScript 5
  - TailwindCSS
  - Shadcn UI
  - React Query
  - Axios
  - Ethers.js
  - Web3Modal
  - IPFS HTTP Client

构建工具:
  - Node.js 18
  - npm
```

## 3. 服务设计

### 3.1 区块链服务 (blockchain-service)
```yaml
端口: 8084
职责: 
  - 智能合约交互
  - NFT管理
  - 通证管理
  - 交易处理
  - 版税分配

API接口:
  # NFT相关
  POST /api/v1/blockchain/nft/mint:
    描述: 铸造音乐NFT
    请求头:
      Authorization: Bearer <token>
    请求体:
      musicId: string    # 音乐ID
      title: string      # NFT标题
      description: string # NFT描述
      royaltyBps: integer # 版税比例(基点)
      price: string      # 初始价格(ETH)
    响应:
      tokenId: string    # NFT Token ID
      txHash: string     # 交易哈希
      
  GET /api/v1/blockchain/nft/{tokenId}:
    描述: 获取NFT详情
    响应:
      tokenId: string    # Token ID
      owner: string      # 所有者地址
      creator: string    # 创作者地址
      musicId: string    # 音乐ID
      metadata: object   # NFT元数据
      history: array     # 交易历史
      
  # 通证相关
  POST /api/v1/blockchain/token/transfer:
    描述: 转账平台通证
    请求头:
      Authorization: Bearer <token>
    请求体:
      to: string         # 接收地址
      amount: string     # 转账金额
    响应:
      txHash: string     # 交易哈希
      
  GET /api/v1/blockchain/token/balance:
    描述: 查询通证余额
    请求头:
      Authorization: Bearer <token>
    响应:
      balance: string    # 余额
      
  # 市场相关
  POST /api/v1/blockchain/market/list:
    描述: 上架NFT
    请求头:
      Authorization: Bearer <token>
    请求体:
      tokenId: string    # NFT Token ID
      price: string      # 价格(ETH)
    响应:
      listingId: string  # 上架ID
      txHash: string     # 交易哈希
      
  POST /api/v1/blockchain/market/buy:
    描述: 购买NFT
    请求头:
      Authorization: Bearer <token>
    请求体:
      listingId: string  # 上架ID
    响应:
      txHash: string     # 交易哈希

数据模型:
  NFTToken:
    - id: UUID (PK)
    - tokenId: String
    - musicId: UUID (FK)
    - creatorId: UUID (FK)
    - ownerId: UUID (FK)
    - contractAddress: String
    - metadata: JSONB
    - royaltyBps: Integer
    - status: Enum (MINTED, LISTED, SOLD)
    - createdAt: Timestamp
    - updatedAt: Timestamp
    
  TokenTransaction:
    - id: UUID (PK)
    - fromId: UUID (FK)
    - toId: UUID (FK)
    - amount: Decimal
    - type: Enum (TRANSFER, REWARD, ROYALTY)
    - txHash: String
    - status: Enum (PENDING, CONFIRMED, FAILED)
    - createdAt: Timestamp
    
  MarketListing:
    - id: UUID (PK)
    - tokenId: String (FK)
    - sellerId: UUID (FK)
    - price: Decimal
    - status: Enum (ACTIVE, SOLD, CANCELLED)
    - createdAt: Timestamp
    - updatedAt: Timestamp
```

## 4. 智能合约设计

### 4.1 合约架构
```solidity
// 平台通证合约
contract MusicToken is ERC20, Ownable {
    string public constant name = "Music Token";
    string public constant symbol = "MUSIC";
    uint8 public constant decimals = 18;
    uint256 public constant INITIAL_SUPPLY = 1000000000 * 10**18;
    
    constructor() ERC20(name, symbol) {
        _mint(msg.sender, INITIAL_SUPPLY);
    }
    
    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }
}

// 音乐NFT合约
contract MusicNFT is ERC721URIStorage, ERC2981 {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;
    
    mapping(uint256 => address) public creators;
    
    constructor() ERC721("Music NFT", "MNFT") {}
    
    function mint(
        address creator,
        string memory tokenURI,
        uint96 royaltyBps
    ) external returns (uint256) {
        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();
        
        _mint(creator, newTokenId);
        _setTokenURI(newTokenId, tokenURI);
        _setTokenRoyalty(newTokenId, creator, royaltyBps);
        creators[newTokenId] = creator;
        
        return newTokenId;
    }
    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC2981)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}

// 市场合约
contract MusicMarket is ReentrancyGuard {
    using Counters for Counters.Counter;
    Counters.Counter private _listingIds;
    
    struct Listing {
        uint256 listingId;
        uint256 tokenId;
        address seller;
        uint256 price;
        bool active;
    }
    
    mapping(uint256 => Listing) public listings;
    IERC721 public nftContract;
    
    constructor(address _nftContract) {
        nftContract = IERC721(_nftContract);
    }
    
    function createListing(
        uint256 tokenId,
        uint256 price
    ) external returns (uint256) {
        require(
            nftContract.ownerOf(tokenId) == msg.sender,
            "Not token owner"
        );
        require(
            nftContract.isApprovedForAll(msg.sender, address(this)),
            "Market not approved"
        );
        
        _listingIds.increment();
        uint256 listingId = _listingIds.current();
        
        listings[listingId] = Listing(
            listingId,
            tokenId,
            msg.sender,
            price,
            true
        );
        
        return listingId;
    }
    
    function buyNFT(uint256 listingId) external payable nonReentrant {
        Listing storage listing = listings[listingId];
        require(listing.active, "Listing not active");
        require(msg.value >= listing.price, "Insufficient payment");
        
        listing.active = false;
        
        // 处理版税
        address creator = IERC2981(address(nftContract))
            .royaltyInfo(listing.tokenId, msg.value)
            .receiver;
        uint256 royaltyAmount = IERC2981(address(nftContract))
            .royaltyInfo(listing.tokenId, msg.value)
            .royaltyAmount;
            
        // 转移NFT
        nftContract.safeTransferFrom(
            listing.seller,
            msg.sender,
            listing.tokenId
        );
        
        // 支付版税
        if (royaltyAmount > 0) {
            payable(creator).transfer(royaltyAmount);
        }
        
        // 支付卖家
        payable(listing.seller).transfer(msg.value - royaltyAmount);
    }
}
```

## 5. 数据库设计

### 5.1 新增表结构
```sql
-- NFT代币表
CREATE TABLE nft_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    token_id VARCHAR(100) NOT NULL UNIQUE,
    music_id UUID NOT NULL REFERENCES music(id),
    creator_id UUID NOT NULL REFERENCES users(id),
    owner_id UUID NOT NULL REFERENCES users(id),
    contract_address VARCHAR(42) NOT NULL,
    metadata JSONB NOT NULL,
    royalty_bps INTEGER NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 通证交易表
CREATE TABLE token_transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    from_id UUID NOT NULL REFERENCES users(id),
    to_id UUID NOT NULL REFERENCES users(id),
    amount DECIMAL NOT NULL,
    type VARCHAR(20) NOT NULL,
    tx_hash VARCHAR(66) NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 市场挂单表
CREATE TABLE market_listings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    token_id VARCHAR(100) NOT NULL REFERENCES nft_tokens(token_id),
    seller_id UUID NOT NULL REFERENCES users(id),
    price DECIMAL NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_nft_tokens_music ON nft_tokens(music_id);
CREATE INDEX idx_nft_tokens_creator ON nft_tokens(creator_id);
CREATE INDEX idx_nft_tokens_owner ON nft_tokens(owner_id);
CREATE INDEX idx_token_transactions_from ON token_transactions(from_id);
CREATE INDEX idx_token_transactions_to ON token_transactions(to_id);
CREATE INDEX idx_market_listings_seller ON market_listings(seller_id);
CREATE INDEX idx_market_listings_status ON market_listings(status);
```

## 6. 部署架构

### 6.1 开发环境
```yaml
docker-compose.yml:
  services:
    blockchain-service:
      build: ./blockchain-service
      ports:
        - "8084:8084"
      environment:
        - SPRING_PROFILES_ACTIVE=dev
        - SPRING_DATASOURCE_URL=jdbc:postgresql://postgres:5432/aimusic
        - SPRING_DATASOURCE_USERNAME=postgres
        - SPRING_DATASOURCE_PASSWORD=postgres
        - SPRING_REDIS_HOST=redis
        - SPRING_REDIS_PORT=6379
        - JWT_SECRET=${JWT_SECRET}
        - ETH_NETWORK=polygon-mumbai
        - ETH_NODE_URL=${ETH_NODE_URL}
        - CONTRACT_OWNER_KEY=${CONTRACT_OWNER_KEY}
        - IPFS_NODE_URL=${IPFS_NODE_URL}
      depends_on:
        - postgres
        - redis
        - ipfs
        - user-auth-service

    ipfs:
      image: ipfs/kubo:latest
      ports:
        - "4001:4001"
        - "5001:5001"
        - "8080:8080"
      volumes:
        - ipfs_data:/data/ipfs
        - ipfs_export:/export

    # 继承V0.4其他服务配置

volumes:
  ipfs_data:
  ipfs_export:
  # 继承V0.4其他volumes
```

## 7. 激励机制设计

### 7.1 通证分配
```yaml
初始分配:
  - 平台储备: 30%
  - 创作者激励: 30%
  - 社区治理: 20%
  - 生态建设: 20%

获取途径:
  创作激励:
    - 音乐创作: 100-1000 MUSIC
    - NFT铸造: 50 MUSIC
    - 版税收入: 2.5% 转换为MUSIC
    
  互动激励:
    - 评论互动: 1-5 MUSIC
    - 分享推广: 10 MUSIC
    - 策展推荐: 20 MUSIC
    
  持币权益:
    - 平台功能折扣
    - 治理投票权重
    - 专属NFT资格
```

### 7.2 NFT经济模型
```yaml
铸造规则:
  - 最低质量要求
  - 版税比例限制
  - 定价区间限制
  
交易规则:
  - 平台手续费: 2.5%
  - 创作者版税: 5-10%
  - 二级市场版税
  
价值锚定:
  - 音乐播放量
  - 社交互动度
  - 创作者影响力
  - 市场供需关系
```

## 8. 测试策略

### 8.1 测试范围
```yaml
单元测试:
  - 智能合约功能
  - 通证交易逻辑
  - NFT铸造流程
  - 市场交易处理
  
集成测试:
  - 区块链交互
  - IPFS存储
  - 合约事件处理
  - 数据一致性
  
安全测试:
  - 合约漏洞扫描
  - 权限控制验证
  - 交易签名验证
  - 重入攻击防护
```

## 9. 监控告警

### 9.1 监控指标
```yaml
系统指标:
  - 合约调用延迟
  - Gas费用统计
  - IPFS存储容量
  - 交易确认时间
  
业务指标:
  - NFT铸造量
  - 交易成交额
  - 通证流通量
  - 用户参与度
```

## 10. 升级规划

下一版本(V1.0)计划:
1. 添加DAO治理系统
2. 实现跨链资产桥接
3. 支持更多公链集成 